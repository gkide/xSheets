---
tags: [ terminal, shell, bash, zsh ]
---
# 特殊变量    预定义的, 内置的特殊变量
# 环境变量    所有的程序均可访问，export VarName=...
# 局部变量    在脚本或命令中定义，仅当前 shell 实例中有效

# https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html
set -e # 如果命令返回非 0 值，则立即退出

VarName="test"           # 创建普通变量, 等号两边不能有空格
local VarName="test"     # 创建局部变量, local 定义函数体内局部变量, 函数体外无法访问
readonly VarName="value" # 创建只读变量, 这种变量不可以被修改
echo $VarName            # 变量引用
echo ${VarName}          # 变量引用
unset VarName            # 删除变量, 只读变量无法删除

# 获取字符串长度
echo "abc" | wc -L
expr length "abc"
xyz="ab"; expr length $xyz
xyz="abx"; echo ${#xyz}
echo "Alex" | awk '{ print length($0) }'

# 传参传递
$0  代表执行的脚本文件名
$$  脚本运行的当前进程号
$！ 后台运行的最后一个进程的ID
$?  显示最后命令的退出状态: 0表示没有错误，其它值表示有错误

$1  代表传入的第1个参数, 脚本/函数第 1 个参数
$n  代表传入的第n个参数, 脚本/函数第 2 个参数

$#  参数个数, 脚本/函数参数个数
$*  以单个字符串显示所有参数
$@  与 $* 相同，但是使用时加引号，并在引号中返回每个参数

funcName() { # function 关键字可以省略
  ...
  local xyz="what" # 函数局部变量，仅函数内可以访问
  return 0; # 返回 0 表示成功，非 0 表示失败
}

function funcName() {
  ...
  # 函数返回之只能是整数
}

# bash 仅支持一维数组，不支持多维数组
#
# 定义 数组名=(元素1 元素2 元素1 ... 元素N)
# 定义 数组名=([下标1]=值1 [下标2]=值2 ... [下标N]=值N)
# 赋值 数组名[下标]=值
# 引用 ${数组名[下标]}

a=(1 2 3 4 5 6)
b=("hello" "shell")
for ((i=0; i<10; i++)); do
  echo "a[$i]=${a[$i]}" # 数组数字索引从 0 开始
done
echo ${a[*]}          # 显示数组全部内容
echo ${a[@]}          # 显示数组全部内容
echo "${#a[*]}"       # 显示数组长度, 元素个数
c=(${a[*]} ${b[*]})   # 合并数组
unset a[5]            # 删除数组指定下标元素
unset a               # 删除整个数组

# 条件控制
if COND; then
  ...
fi
# -------------------------------------
if COND; then
  ...
else
  ...
fi
# -------------------------------------
if COND; then
  ...
elif COND; then
  ...
else
  ...
fi
# =====================================
for ((i=0; i<100; i++)); do
  ...
  break
  continue
done
# -------------------------------------
for Var in item1 item2 ... itemN; do
  ...
done
# -------------------------------------
for (( ; ; )); do # 无限循环
  ...
done
# =====================================
while COND; do
  ...
  break
  continue
done
# -------------------------------------
idx=0;
while (($idx<100)); do
  ...
  let "idx++"
done
# -------------------------------------
while :; do # 无限循环
  ...
done
# -------------------------------------
while true; do # 无限循环
  ...
done
# =====================================
until COND; do
  ...
  break
  continue
done
# =====================================
case "$VAR" in
  "what") # VAR 检测是否匹配 what
    ;; # 表示 break，跳出整个 case … esac 语句
  "x1"|"x2") # 匹配 x1 或 x2
  ...
  *) # 上述均没有匹配，则匹配此项
    ;;
esac
# =====================================
select VAR in Seq1 Seq2 ...; do
  # 显示出带编号的菜单，用户出入不同编号
  # 就可以选择不同的菜单，并执行不同的功能
  ...
done

select VAR in "Linux" "Mac" "Win"; do
  break;
done
echo "You have selected $VAR"

# 数学运算, bash 不支持简单的数学运算，通常要通过其它命令来实现
a=1; b=2;
expr $a + $b    # 加法
expr $a - $b    # 减法
expr $a \* $b   # 乘法
expr $b / $a    # 除法
expr $b % $a    # 取余
a=$b            # 赋值

echo $[1+2]                   # 计算并显示
let var=a+b                   # 计算并将结果赋值给变量
val=`expr $a + $b`            # 计算并将结果赋值给变量
val=$(expr $a + $b)           # 计算并将结果赋值给变量
((val=a+b))                   # 常在 if/for/while 条件判断中需要计算时使用
var=$(echo "(1.1+2.1)" | bc)  # 调用 bc 计算器

# test 和 [ ] 检测, 符合 POSIX 标准，兼容性更强
[ $a -eq $b ]   # 数值比较, 相等则 true
[ $a -ne $b ]   # 数值比较, 不等则 true
[ $a -gt $b ]   # 数值比较, a > b  则 true
[ $a -lt $b ]   # 数值比较, a < b  则 true
[ $a -ge $b ]   # 数值比较, a >= b 则 true
[ $a -le $b ]   # 数值比较, a <= b 则 true

[ -z "$Var" ]   # 字符串为空，则 true
[ -n "$Var" ]   # 字符串非空，则 true

[ $a == $b ]    # 字符串比较, 相等则 true
[ $a != $b ]    # 字符串比较, 不等则 true

[ ! EXPR ]           # 非运算
[ EXPR1 -o EXPR2 ]   # 或运算
[ EXPR1 -a EXPR2 ]   # 与运算

-a/-e FILE  # True if file exists
-h/-L FILE  # True if file is a symbolic link
-s FILE     # True if file exists and is not empty

-d FILE     # True if file is a directory
-f FILE     # True if file exists and is a regular file

-r FILE     # True if file is readable by you
-w FILE     # True if the file is writable by you
-x FILE     # True if the file is executable by you
-O FILE     # True if the file is effectively owned by you
-G FILE     # True if the file is effectively owned by your group

FILE1 -ef FILE2  # True if file1 is a hard link to file2
FILE1 -nt FILE2  # True if file1 is newer than file2, according to modification date
FILE1 -ot FILE2  # True if file1 is older than file2, according to modification date

[[ ! EXPR ]]
[[ EXPR1 || EXPR2 ]]
[[ EXPR1 && EXPR2 ]]

v="A*"; [ $v == A* ] && echo Y || echo N    # 字符匹配 => Y
v="Aab"; [ $v == A* ] && echo Y || echo N   # 字符匹配 => N

v="Aab"; [[ $v == A* ]] && echo Y || echo N # 模式匹配 => Y
v="hello world"; [[ $v =~ "world" ]] && echo Y || echo N    # 正则匹配 => Y

# 使用 () 进行分组
 [ 1 == 1 -a (2 == 2 -o 3 == 4) ]  && echo Y || echo N # 仅脚本运行时支持 => Y
[[ 1 == 1 && (2 == 2 || 3 == 4) ]] && echo Y || echo N # 脚本/手动输入均支持 => Y

##########
# 重定向 #
##########
# stdin(0): 标准输入, stdout(1): 标准输出, stderr(2): 标准错误
# => https://zsh.sourceforge.io/Doc/Release/Redirection.html
# => https://www.gnu.org/software/bash/manual/html_node/Redirections.html

>  file  # 覆盖式重定向到文件 file, file 不存在则创建, 默认 stdout
1> file  # 覆盖式重定向到文件 file, file 不存在则创建, 明确 stdout
>> file  # 追加式重定向到文件 file, file 不存在则创建, 默认 stdout
1>> file # 追加式重定向到文件 file, file 不存在则创建, 明确 stdout

2> file  # 覆盖式重定向到文件 file, file 不存在则创建, 明确 stderr
2>> file # 追加式重定向到文件 file, file 不存在则创建, 明确 stderr

# 将 cmd 命令的 stdout 和 stderr 同时重定向到 cmd
cmd  > cmd.log 2>&1 # all shell works well
cmd 1> cmd.log 2>&1 # all shell works well
cmd >& cmd.log      # bash/zsh works well
cmd &> cmd.log      # bash/zsh works well, preferred

# 将 cmd 命令的 stdout 和 stderr 同时追加重定向到 cmd.log
cmd &>> cmd.log     # only way works for bash
cmd >>& cmd.log     # also works for zsh
cmd >> cmd.log 2>&1

# 将 cmd1 命令的 stdout 重定向到 cmd2 命令的 stdin
cmd1 | cmd2

# 将 cmd 命令的 stdin 重定向为 file 文件
cmd < file

############
# 变量扩展 #
############
${#VAR}       # 计算并显示 VAR 变量字符串的长度

${VAR#*STR}   # 从左向右截取第一个 STR 后的字符串
${VAR##*STR}  # 从左向右截取最后一个 STR 后的字符串

${VAR#*.}     # 去掉变量 VAR 左起的  第一个 . 字符及其左边的内容，返回左起  第一个 .（不含该字符）字符右边的内容
${VAR##*/}    # 去掉变量 VAR 左起的最后一个 / 字符及其左边的内容，返回左起最后一个 /（不含该字符）字符右边的内容
${VAR##*.}    # 去掉变量 VAR 左起的最后一个 . 字符及其左边的内容，返回左起最后一个 .（不含该字符）字符右边的内容

${VAR%STR*}   # 从右向左截取第一个 STR 后的字符串
${VAR%%STR*}  # 从右向左截取最后一个 STR 后的字符串

${VAR%/*}     # 去掉变量 VAR 右起的  第一个 / 字符及其右边的内容，返回右起  第一个 /（不含该字符）字符左边的内容
${VAR%%.*}    # 去掉变量 VAR 右起的最后一个 . 字符及其右边的内容，返回右起最后一个 .（不含该字符）字符左边的内容
${VAR%%/*}    # 去掉变量 VAR 右起的最后一个 / 字符及其右边的内容，返回右起最后一个 /（不含该字符）字符左边的内容

# Here Document, 一种特殊的重定向方式
# => delimiter, 可以是任意字符串
command << delimiter
all the stuff will
send to command, include new-line LF
delimiter

############
# Also See #
############
cheat -t zsh
cheat -t bash
cheat -t shell
cheat -t terminal
